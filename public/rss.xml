<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog.abrochard.com]]></title><description><![CDATA[abrochard tech blog]]></description><link>https://blog.abrochard.com</link><image><url>https://blog.abrochard.com/favicon.ico</url><title>blog.abrochard.com</title><link>https://blog.abrochard.com</link></image><generator>RSS for Node</generator><lastBuildDate>Wed, 14 Oct 2020 15:05:21 GMT</lastBuildDate><atom:link href="https://blog.abrochard.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 14 Oct 2020 15:05:21 GMT</pubDate><copyright><![CDATA[2020 Adrien Brochard]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[Adrien Brochard]]></managingEditor><webMaster><![CDATA[Adrien Brochard]]></webMaster><ttl>60</ttl><category><![CDATA[tech]]></category><category><![CDATA[blog]]></category><category><![CDATA[emacs]]></category><item><title><![CDATA[Announcing the Emacs User Survey 2020]]></title><description><![CDATA[<head><title>Announcing the Emacs User Survey 2020</title></head>
<div class="title-header"><h1>Announcing the Emacs User Survey 2020</h1>
<a href="/ann-emacs-survey-2020.html">Link</a></div>
<p>The first iteration of the Emacs User Survey is currently on track to open up Monday October 19th 2020.</p>
<p>A huge thanks to everyone who gave feedback and suggestions, and particularly u/yyoncho who had put together a great list of questions on r/emacs.</p>
<h2 id="header-1"><span class="section-number">1</span>Why</h2>
<p>For the community to understand itself better.</p>
<h2 id="header-2"><span class="section-number">2</span>Where</h2>
<p><a href="https://emacssurvey.org">https://emacssurvey.org</a></p>
<h2 id="header-3"><span class="section-number">3</span>When</h2>
<p>The survey will be open from Monday October 19th to Monday November 30th.</p>
<h2 id="header-4"><span class="section-number">4</span>How</h2>
<p>Two ways to submit the survey:</p>
<ul><li>online form</li>
<li>filling out a template and emailing it back</li>
</ul>
<h2 id="header-5"><span class="section-number">5</span>Who</h2>
<p>Questions or comments can go to <a href="mailto:contact@emacssurvey.org">contact@emacssurvey.org</a></p>
<h2 id="header-6"><span class="section-number">6</span>What you can do to help</h2>
Once the survey is open, you can<ul><li>fill it out!</li>
<li>most importantly, share it with your Emacs friends!<ul><li>blog about it</li>
<li>email your colleagues who also use Emacs</li>
<li>etc</li>
</ul>
</li>
</ul>

<div class="footer">10/14/2020</div>]]></description><link>https://blog.abrochard.com/ann-emacs-survey-2020.html</link><guid isPermaLink="true">https://blog.abrochard.com/ann-emacs-survey-2020.html</guid></item><item><title><![CDATA[Continuous Integration of Emacs Packages with CircleCI]]></title><description><![CDATA[<head><title>Continuous Integration of Emacs Packages with CircleCI</title></head>
<div class="title-header"><h1>Continuous Integration of Emacs Packages with CircleCI</h1>
<a href="/circleci-for-emacs-packages.html">Link</a></div>
<p>I was very inspired by <a href="https://emacsconf.org/2019/talks/16/">Damien Cassou&#39;s great presentation</a> during EmacsConf 2019 to write this post and I encourage you to check it out if you haven&#39;t already. In short, when writing packages for Emacs, it is best practice to run several quality tools on them, like syntax and documentation checkers, or even <a href="https://blog.abrochard.com/ert-tests.html">ERT Tests</a>. But once these packages are public and pull requests start coming in, it is a huge time saver to have these same tools ran automatically and provide feedback to contributors. That&#39;s right, we&#39;re talking about Continuous Integration for Emacs packages.</p>
<h2 id="header-1"><span class="section-number">1</span>Why CircleCI</h2>
<p>There are many CI/CD services out there that can help us out. Damien Cassou shows examples with Travis, Gitlab and Drone, but I wanted to focus on CircleCI. It&#39;s far from perfect but their free tier is decent, their markdown badge is pretty, and I wrote a <a href="https://github.com/abrochard/magit-circleci">CircleCI Magit extension</a> to show the build status in Emacs (ie. an extension for an Emacs extension).</p>
<h2 id="header-2"><span class="section-number">2</span>Run Steps</h2>
<p>We want a few things to happen automatically:</p>
<ul><li>install package dependencies from Elpa/Melpa/Org</li>
<li>run ERT tests</li>
<li>byte compile</li>
<li>lint package</li>
</ul>
<p>To keep things simple, I will use my package <a href="https://github.com/abrochard/kubel">kubel</a> as the guinea pig here.</p>
<h2 id="header-3"><span class="section-number">3</span>CircleCI Config Skeleton</h2>
<p>Leaving out the actual commands, we can start with a simple draft of the <code>.circleci/config.yml</code> that uses the docker image for Emacs 27.1 as our base:</p>
<pre class="prettyprint"><code class="language-yaml">  version: 2.1

  jobs:
    build:
      docker:
        - image: silex/emacs:27.1
      working_directory: /kubel
      steps:
        - run: apt update &#38;&#38; apt install -y git ssh
        - checkout
        - run:
            name: Install packages
            command: TBD

        - run:
            name: ERT tests
            command: TBD

        - run:
            name: Compile
            command: TBD

        - run:
            name: Lint
            command: TBD</code>
</pre>
<p>Note that the <code>silex/emacs</code> image doesn&#39;t come with git and ssh installed, and that we need to <code>apt install</code> them first thing as they are required to run the code checkout step.</p>
<h2 id="header-4"><span class="section-number">4</span>Emacs Lisp Code</h2>
<p>Let&#39;s translate the desired run steps into actual Emacs Lisp Code for Kubel:</p>
<ul><li>my package dependencies are transient, dash, yaml-mode and s<pre class="prettyprint"><code class="language-emacs-lisp">    (let ((my-packages &#39;(transient dash yaml-mode s)))
      (add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;) t)
      (package-initialize)
      (package-refresh-contents)
      (package-install &#39;package-lint) ;; we&#39;ll need it later
      (dolist (pkg my-packages)
        (package-install pkg)))</code>
</pre>
</li>
<li>run ERT tests in <code>test/kubel-test.el</code><pre class="prettyprint"><code class="language-emacs-lisp">    (load-file &#34;kubel.el&#34;) ;; load code first
    (load-file &#34;test/kubel-test.el&#34;)
    (ert-run-tests-batch-and-exit)</code>
</pre>
</li>
<li>simple byte compile with warnings not counting as errors<pre class="prettyprint"><code class="language-emacs-lisp">    (setq byte-compile-error-on-warn nil)
    (batch-byte-compile)</code>
</pre>
</li>
<li>run <code>package-lint</code>, this time with warnings counting as errors<pre class="prettyprint"><code class="language-emacs-lisp">    (require &#39;package-lint)
    (setq package-lint-batch-fail-on-warnings t)
    (package-lint-batch-and-exit)</code>
</pre>
</li>
</ul>
<h2 id="header-5"><span class="section-number">5</span>How to trigger from CLI</h2>
<p>This is probably the biggest hurdle: how to run Emacs Lisp Code from the command line in an elegant manner? There are quite a few solutions out there to help with this: Damien Cassou&#39;s <a href="https://gitea.petton.fr/DamienCassou/makel">fancy Makefile</a>, collections of <a href="https://github.com/alphapapa/makem.sh">bash script</a>, and <a href="https://github.com/alphapapa/makem.sh#comparisons">plenty of others</a>. However I am not completely convinced by any of them as I find the syntax always a bit clunky and hard to read. I am currently settled with putting all the Emacs Lisp code into a single <code>make.el</code> file, and call the individual step functions via the <code>--funcall</code> option in the CLI.</p>
<p>Here is the full <code>make.el</code> which I find quite readable:</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (require &#39;package)

  (defconst make-packages
    &#39;(transient dash yaml-mode s))

  (defun make-init ()
    (add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;) t)
    (package-initialize))

  (defun make-install-packages ()
    (make-init)
    (package-refresh-contents)
    (package-install &#39;package-lint)
    (dolist (pkg make-packages)
      (package-install pkg)))

  (defun make-ert ()
    (make-init)
    (load-file &#34;/kubel/kubel.el&#34;)
    (load-file &#34;/kubel/test/kubel-test.el&#34;)
    (ert-run-tests-batch-and-exit))

  (defun make-compile ()
    (make-init)
    (setq byte-compile-error-on-warn nil)
    (batch-byte-compile))

  (defun make-lint ()
    (make-init)
    (require &#39;package-lint)
    (setq package-lint-batch-fail-on-warnings t)
    (package-lint-batch-and-exit))

  (provide &#39;make)
  ;;; make.el ends here</code>
</pre>
<p>And from there I can call my step functions directly:</p>
<pre class="prettyprint"><code class="language-bash">  emacs -Q --batch -l make.el --funcall make-install-packages
  emacs -Q --batch -l make.el --funcall make-ert
  emacs -Q --batch -l make.el --funcall make-compile kubel.el
  emacs -Q --batch -l make.el --funcall make-lint kubel.el</code>
</pre>
<h2 id="header-6"><span class="section-number">6</span>Putting It All Together</h2>
<p>I placed my <code>make.el</code> file in the <code>.circleci</code> folder to keep things organized:</p>
<pre class="prettyprint"><code class="language-yaml">  version: 2.1

  jobs:
    build:
      docker:
        - image: silex/emacs:27.1
      working_directory: /kubel
      steps:
        - run: apt update &#38;&#38; apt install -y git ssh make
        - checkout
        - run:
            name: Install packages
            command: |
              emacs -Q --batch -l .circleci/make.el --funcall make-install-packages

        - run:
            name: ERT tests
            command: |
              emacs -Q --batch -l .circleci/make.el --funcall make-ert

        - run:
            name: Compile
            command: |
              emacs -Q --batch -l .circleci/make.el --funcall make-compile kubel.el

        - run:
            name: Lint
            command: |
              emacs -Q --batch -l .circleci/make.el --funcall make-lint kubel.el</code>
</pre>
<p>This will nicely run all our steps in order on Emacs 27.1 on every commit.</p>
<p><img src="https://blog.abrochard.com/content/img/circleci-build.png" alt="CircleCI build dashboard" title="CircleCI build dashboard"/></p>
<h2 id="header-7"><span class="section-number">7</span>Can We Do Better?</h2>
<p>Yes!</p>
<p>Running tests and linter and whatnot is very nice, but I think there&#39;s an even bigger benefit we can reap here from spinning up a fully isolated Emacs instance. We can answer questions which are often harder to investigate locally:</p>
<ul><li>how can we make sure we truly only depend on the packages we say we depend on?</li>
<li>how can we make sure our package actually works on the all the Emacs versions we say we support?</li>
</ul>
<p>We already answer the first question thanks to the dockerized Emacs and the controlled external package installation. For the second question, we can parallelize the build steps to run on multiple Emacs versions all at once:</p>
<pre class="prettyprint"><code class="language-yaml">  version: 2.1

  steps: &#38;steps
    working_directory: /kubel
    steps:
      - run: apt update &#38;&#38; apt install -y git ssh make
      - checkout
      - run:
          name: Install packages
          command: |
            emacs -Q --batch -l .circleci/make.el --funcall make-install-packages

      - run:
          name: ERT tests
          command: |
            emacs -Q --batch -l .circleci/make.el --funcall make-ert

      - run:
          name: Compile
          command: |
            emacs -Q --batch -l .circleci/make.el --funcall make-compile kubel.el

      - run:
          name: Lint
          command: |
            emacs -Q --batch -l .circleci/make.el --funcall make-lint kubel.el

  jobs:
    emacs-27:
      docker:
        - image: silex/emacs:27.1
      &#60;&#60;: *steps
    emacs-26:
      docker:
        - image: silex/emacs:26.3
      &#60;&#60;: *steps
    emacs-25:
      docker:
        - image: silex/emacs:25.3
      &#60;&#60;: *steps

  workflows:
    version: 2
    build:
      jobs:
        - emacs-25
        - emacs-26
        - emacs-27</code>
</pre>
<p><img src="https://blog.abrochard.com/content/img/circleci-pr.png" alt="CircleCI PR Checks" title="CircleCI PR Checks"/></p>
<h2 id="header-8"><span class="section-number">8</span>Final Words &#38; Further Reading</h2>
<p>Why not use docker and a trendy CI/CD system to run integration tasks for extensions of a Babylonian software?</p>
<p>I encourage you to checkout:</p>
<ul><li><a href="https://emacsconf.org/2019/talks/16/">Damien Cassou&#39;s full presentation</a></li>
<li><a href="https://github.com/Silex/docker-emacs">Silex&#39; Dockerized Emacs</a></li>
<li><a href="https://circleci.com/docs/">CircleCI Doc</a></li>
</ul>

<div class="footer">9/11/2020</div>]]></description><link>https://blog.abrochard.com/circleci-for-emacs-packages.html</link><guid isPermaLink="true">https://blog.abrochard.com/circleci-for-emacs-packages.html</guid></item><item><title><![CDATA[ERT: Emacs Lisp Regression Testing]]></title><description><![CDATA[<head><title>ERT: Emacs Lisp Regression Testing</title></head>
<div class="title-header"><h1>ERT: Emacs Lisp Regression Testing</h1>
<a href="/ert-tests.html">Link</a></div>
<p>This is the written version of a lightning talk I recently gave at the <a href="https://emacsnyc.org/">NYC Emacs Meetup</a>, which is a great meetup that I cannot recommend enough.</p>
<h2 id="header-1"><span class="section-number">1</span>Why</h2>
The goal is simple: automatically make sure that a program is not broken by writing tests for it and running them automatically.<p>Emacs lisp in particular is a good candidate for automated testing because it is ancient and quirky, provides no static types, and is often the result of many individual contributors. And to make things super easy, Emacs is shipped with <code>ert</code>, the Emacs Lisp Regression Testing library to write and run tests.</p>
<h2 id="header-2"><span class="section-number">2</span>Simple example</h2>
Let&#39;s start by writing a <code>silly</code> package in a <code>silly.el</code> file with some silly functions like this <code>silly-division</code><pre class="prettyprint"><code class="language-emacs-lisp">    (defun silly-division (a b)
      &#34;Silly divide A by B.&#34;
      (if (equal b 1)
          a
        (/ a b)))</code>
</pre>
<ol><li>divide a by b</li>
<li>if b is 1, spare ourselves the computation and return a</li>
</ol>
<h3 id="header-2-1"><span class="section-number">2.1</span>Simple test</h3>
We can now write our first silly test:<pre class="prettyprint"><code class="language-emacs-lisp">     (require &#39;ert)

     (ert-deftest silly-test-division ()
       (should (equal 4 (silly-division 8 2))))</code>
</pre>
<ol><li>import the <code>ert</code> library</li>
<li>create a test named <code>silly-test-division</code></li>
<li>make sure that in our world <code>8/2 = 4</code></li>
</ol>
<p>For practical reasons, I would write my tests in a file named <code>silly-test.el</code> next to <code>silly.el</code>.</p>
<h3 id="header-2-2"><span class="section-number">2.2</span>How to run</h3>
You can run a test interactively via <code>M-x ert</code> and selecting it, or by evaluating<pre class="prettyprint"><code class="language-emacs-lisp">     (ert &#39;silly-test-division)</code>
</pre>
<p><img src="https://blog.abrochard.com/content/img/ert-results.png" alt="ert-results" title="ert-results"/></p>
<p>Once ran, you will be in the debugging editor where you can:</p>
<ul><li>&#34;TAB&#34; to move around</li>
<li>&#34;.&#34; to jump to code</li>
<li>&#34;b&#34; for backtrace</li>
<li>&#34;l&#34; to show all <code>should</code> statements</li>
</ul>
<h3 id="header-2-3"><span class="section-number">2.3</span>Testing multiple cases</h3>
To be a bit more comprehensive we can pack multiple <code>should</code> statements in the same test. This allows us to look at multiple cases while still keeping the test results clear.<pre class="prettyprint"><code class="language-emacs-lisp">     (ert-deftest silly-test-division ()
       (should (equal 4 (silly-division 8 2)))
       (should (equal 2 (silly-division 10 5)))
       (should (equal 10 (silly-division 10 1)))
       (should (equal 2 (silly-division 8 4))))

     (ert &#39;silly-test-division)</code>
</pre>
<p>Remember that the &#34;l&#34; key in the tests results buffer will show all the <code>should</code> statements individually:</p>
<p><img src="https://blog.abrochard.com/content/img/ert-should-list.png" alt="ert-should-list" title="ert-should-list"/></p>
<h3 id="header-2-4"><span class="section-number">2.4</span>Testing for error</h3>
Sometimes it can be useful to make sure that our code errors under certain scenarios. In the case of <code>silly-division</code>, we do want to throw an error if the user tries to divide by zero. To test that, we can use the <code>should-error</code> function and optionally pass the type of error we expect to see.<pre class="prettyprint"><code class="language-emacs-lisp">     (ert-deftest silly-test-division-by-zero ()
       (should-error (silly-division 8 0)
                     :type &#39;arith-error))

     (ert &#39;silly-test-division-by-zero)</code>
</pre>
<h3 id="header-2-5"><span class="section-number">2.5</span>Testing for failure</h3>
An even more under-estimated feature is the ability to write a failing test. This can be very useful for recording known bugs and helping contributors fix things. In our case, <code>silly-division</code> has a problem: it only does integer division. If you run <code>(silly-division 1 2)</code>, you should see the output as 0.<p>Rather than fix our function to perform floating point division, let&#39;s write a test for this bug:</p>
<pre class="prettyprint"><code class="language-emacs-lisp">     (ert-deftest silly-test-float-division-bug ()
       :expected-result :failed
       (should (equal .5 (silly-division 1 2))))

     (ert &#39;silly-test-float-division-bug)</code>
</pre>
When ran, we will see a failure in the result buffer but the failure will be indicated by a green lower-case <code>f</code>.<p><img src="https://blog.abrochard.com/content/img/ert-test-failure.png" alt="ert-test-failure" title="ert-test-failure"/></p>
<h2 id="header-3"><span class="section-number">3</span>Trickier function</h2>
Let&#39;s add another silly function to our <code>silly-package</code><pre class="prettyprint"><code class="language-emacs-lisp">    (defun silly-temp-writer (str)
      (with-temp-buffer
        (insert (format &#34;L %s L&#34; str))
        (write-file &#34;/tmp/silly-write.txt&#34;)))</code>
</pre>
<ol><li>take a string</li>
<li>format it &#34;L %s L&#34;</li>
<li>write that string to &#34;/tmp/silly-write.txt&#34;</li>
<li>don&#39;t return anything</li>
</ol>
<p>How can we reliably test this? And what are we actually trying to test? I would argue that we want to make sure that what ends up being written to the file what we expect.</p>
<h3 id="header-3-1"><span class="section-number">3.1</span>Naive method</h3>
We can try a naive approach which will work:<pre class="prettyprint"><code class="language-emacs-lisp">     (ert-deftest silly-test-temp-writer ()
       (silly-temp-writer &#34;my-string&#34;)
       (should (equal &#34;L my-string L&#34;
                      (with-temp-buffer
                        (insert-file-contents &#34;/tmp/silly-write.txt&#34;)
                        (string-trim (buffer-string))))))

     (ert &#39;silly-test-temp-writer)</code>
</pre>
<ol><li>call <code>silly-temp-write-function</code> with string &#34;my-string&#34;</li>
<li>read the content of &#34;/tmp/silly-write.txt&#34;</li>
<li>remove the new line</li>
<li>compare it to expected result &#34;Lmy-stringL&#34;</li>
</ol>
<p>However, we have a few issues here:</p>
<ul><li>side effects in the test, we are leaving a file on the machine after running the test</li>
<li>no isolation, if another process deletes the file mid-test, we could have a false negative</li>
<li>testing more than we should, we are not just testing our logic but also the <code>write-file</code> function</li>
<li>test complexity, our test is convoluted and hard to read</li>
</ul>
<h3 id="header-3-2"><span class="section-number">3.2</span>Better approach with mocking</h3>
A better approach when trying to test functions which do not return a value or have side-effects is to use mocking. We will temporarily re-wire the <code>write-file</code> function to perform some assertion instead of actually writing to a file on disk.<pre class="prettyprint"><code class="language-emacs-lisp">     (require &#39;cl-macs)

     (ert-deftest silly-test-temp-writer ()
       (cl-letf (((symbol-function &#39;write-file)
                  (lambda (filename)
                    (should (equal &#34;/tmp/silly-write.txt&#34; filename))
                    (should (equal &#34;L my-string L&#34; (buffer-string))))))
         (silly-temp-writer &#34;my-string&#34;)))

     (ert &#39;silly-test-temp-writer)</code>
</pre>
<ol><li>Define a mock <code>write-file</code> function<ul><li>check that we write in the correct location</li>
<li>check that the content is formatted properly</li>
</ul>
</li>
<li>Temporarily replace the real <code>write-file</code> with our mock</li>
<li>Call <code>silly-temp-writer</code></li>
</ol>
<p>We can observe that now most of our issues from the naive test are gone:</p>
<ul><li>Not actually writing to the system or leaving state</li>
<li>Test more and closer to the intended behavior</li>
<li>Not testing something we didn&#39;t intend to (ie. the <code>write-file</code> function)</li>
</ul>
<p>NB: In the past I used to do this with the <code>flet</code> function but apparently it is obsolete since Emacs 24.3. As a replacement, I found that <code>cl-left</code> from the <code>cl-macs</code> library did the job pretty well.</p>
<h2 id="header-4"><span class="section-number">4</span>Running all tests at once</h2>
Now that we have a whole bunch of tests defined, we can run them all once. You may have noticed that all example tests were prefixed the same way, it was to make this task easier by passing a regexp to the <code>ert</code> function:<pre class="prettyprint"><code class="language-emacs-lisp">    (ert &#34;silly-test-*&#34;)</code>
</pre>
<p>And you can take it even further by running the tests from a bash script or a docker command, perfect for your CI pipeline:</p>
<pre class="prettyprint"><code class="language-shell">     docker run -it --rm  -v $(pwd):/silly silex/emacs emacs -batch -l ert -l /silly/silly.el -l /silly/silly-test.el -f ert-run-tests-batch-and-exit</code>
</pre>
<p>Which will output:</p>
<pre class="prettyprint"><code class="language-text">    Running 4 tests (2020-07-08 14:47:49+0000)
       passed  1/4  silly-test-division
       passed  2/4  silly-test-division-by-zero
       failed  3/4  silly-test-float-division-bug
       passed  4/4  silly-test-temp-writer

    Ran 4 tests, 4 results as expected (2020-07-08 14:47:49+0000)
    1 expected failures</code>
</pre>
<h2 id="header-5"><span class="section-number">5</span>Visualizing coverage</h2>
A less known feature, but it is possible to visually see which lines are covered by your tests and how well.<ol><li><code>M-x testcover-start</code></li>
<li>Select the <code>silly.el</code> file</li>
<li>Run tests<pre class="prettyprint"><code class="language-emacs-lisp">       (ert &#34;silly-test-*&#34;)</code>
</pre>
</li>
<li><code>M-x testcover-mark-all</code> and select <code>silly.el</code></li>
<li>See results:<ul><li>red is not evaluated at all</li>
<li>brown is always evaluated with the same value</li>
</ul>
</li>
</ol>
<p><img src="https://blog.abrochard.com/content/img/ert-testcover.png" alt="ert-testcover" title="ert-testcover"/></p>
<p>For example, in this case, we can see that I only have one test case for my <code>silly-division</code> with <code>b</code> equal to 1 and returning <code>a</code> directly.</p>
<h2 id="header-6"><span class="section-number">6</span>Best practices</h2>
<ul><li>ask yourself what you want to test</li>
<li>start by making tests fail, there&#39;s nothing better to insure you are taking the code path you think you are taking</li>
<li>write clean test with no side effect, and if you must have side effect, run a cleanup function afterwards</li>
<li>descriptive test names can really help figure out what is broken</li>
<li>good tests means good debugging</li>
</ul>
<h2 id="header-7"><span class="section-number">7</span>More Resources</h2>
<ul><li><a href="https://www.gnu.org/software/emacs/manual/html_mono/ert.html">ERT Manual</a></li>
<li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Test-Coverage.html">Emacs Manuel on Test Coverage</a></li>
</ul>

<div class="footer">7/29/2020</div>]]></description><link>https://blog.abrochard.com/ert-tests.html</link><guid isPermaLink="true">https://blog.abrochard.com/ert-tests.html</guid></item><item><title><![CDATA[Emacs & Websockets]]></title><description><![CDATA[<head><title>Emacs & Websockets</title></head>
<div class="title-header"><h1>Emacs &#38; Websockets</h1>
<a href="/websockets.html">Link</a></div>
<p>I work with websockets a lot and as painful as they can be sometimes, their versatility easily makes up for it. If you are not familiar, a websocket is basically a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">two way connection between a client and server</a>. You would typically encounter one in a web chat applications, or any use case when you would want the server to send data to the browser without the browser requesting it first.</p>
<p>And of course there is an amazing <a href="https://github.com/ahyatt/emacs-websocket">Emacs extension</a> for it on Elpa thanks to Andrew Hyatt. It&#39;s a bit lacking in explicit documentation, but the <a href="https://github.com/ahyatt/emacs-websocket/blob/master/websocket-functional-test.el">functional tests</a> for it provide the main ideas on how to get started.</p>
<h2 id="header-1"><span class="section-number">1</span>Emacs as a websocket client</h2>
<p>Probably the first use case: how to open a websocket connection from Emacs.</p>
<p>Here is a basic example making use of the  <a href="https://websocket.org/echo.html">websocket.org echo test</a> which echoes back any string sent.</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (require &#39;websocket)

  (setq my-websocket
        (websocket-open &#34;wss://echo.websocket.org&#34;
                        :on-message (lambda (_websocket frame)
                                      (message &#34;ws frame: %S&#34; (websocket-frame-text frame)))
                        :on-close (lambda (_websocket) (message &#34;websocket closed&#34;))))

  (websocket-send-text my-websocket &#34;hello from emacs&#34;)

  (websocket-close my-websocket)</code>
</pre>
<ol><li>we load the websocket extension</li>
<li>we open a new websocket and name it <code>my-websocket</code><ol><li>we provide a function to call when we receive a message from the server: print it out</li>
<li>we provide a function to call when the websocket is closed: message &#34;websocket closed&#34;</li>
</ol>
</li>
<li>we send &#34;hello from emacs&#34; through the websocket</li>
<li>we close the websocket</li>
</ol>
<p>Note that the <code>on-message</code> function is given two arguments:</p>
<ol><li>the websocket object itself, that we are ignoring here</li>
<li>the frame data from which we can extract text with the <code>websocket-frame-text</code> function</li>
</ol>
<p>In terms of output, we see</p>
<pre class="prettyprint"><code class="language-text">ws frame: &#34;hello from emacs&#34;
websocket closed</code>
</pre>
<ol><li>the echo server sending back our original message</li>
<li>the websocket being closed</li>
</ol>
<h2 id="header-2"><span class="section-number">2</span>Emacs as a websocket server</h2>
<p>Now onto the more exotic stuff: how to turn Emacs into a websocket server.</p>
<h3 id="header-2-1"><span class="section-number">2.1</span>Basic Setup</h3>
<p>Let&#39;s start with a basic setup:</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (setq my-websocket-server
        (websocket-server
         3000
         :host &#39;local
         :on-message (lambda (_websocket frame)
                       (message &#34;received message through websocket&#34;))
         :on-open (lambda (_websocket)
                    (message &#34;websocket opened&#34;))
         :on-close (lambda (_websocket)
                     (message &#34;websocket closed&#34;))))
</code>
</pre>
<ol><li>we start a websocket server and call it <code>my-websocket-server</code></li>
<li>the server is running on localhost port 3000</li>
<li>when the server receives a message, we print &#34;received message through websocket&#34;</li>
<li>when a client connects to the server, we print &#34;websocket opened&#34;</li>
<li>when a client closes the websocket, we print &#34;websocket closed&#34;</li>
</ol>
<p>Now to test this code, we could use the sample from the earlier section, but instead let&#39;s use some Javascript code that we will enhance later on. We can paste this in the browser console:</p>
<pre class="prettyprint"><code class="language-javascript">  const ws = new WebSocket(&#34;ws://localhost:3000&#34;);

  ws.onmessage = function(event) {
    console.log(event.data);
  }

  ws.send(&#34;hi&#34;);
  ws.close();</code>
</pre>
<ol><li>we establish a connection to localhost:3000</li>
<li>we register a function to log any frame data coming from the server</li>
<li>we send &#34;hi&#34; to the server and see &#34;hi&#34; echoed back in the console</li>
<li>we close the connection</li>
</ol>
<p>From the Emacs perspective, we see</p>
<pre class="prettyprint"><code class="language-text">websocket opened
received message through websocket
websocket closed</code>
</pre>
<p>And just for the sake of completeness, we should close our server:</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (websocket-server-close my-websocket-server)</code>
</pre>
<h3 id="header-2-2"><span class="section-number">2.2</span>Automatic Refresh on Save</h3>
<p>Let&#39;s do a real use case: trigger the browser to refresh a page when we save some edits. This is a good example because it is the classic case of having a server (Emacs) needing to send a message to the client (the browser) without having client requesting it first. In other words, we don&#39;t want the browser to poll Emacs every X seconds asking if it should refresh, we want Emacs to tell the browser to refresh.</p>
<p>We start with a very simple HTML document that we name &#34;test.html&#34;.</p>
<pre class="prettyprint"><code class="language-html">  &#60;html&#62;
    &#60;body&#62;
      &#60;h1&#62;Hello world&#60;/h1&#62;
    &#60;/body&#62;
    &#60;script&#62;
     const ws = new WebSocket(&#34;ws://localhost:3000&#34;);
     ws.onmessage = function(frame) {
       location.reload();
     }
    &#60;/script&#62;
  &#60;/html&#62;</code>
</pre>
<p>All it shows is &#34;Hello world&#34; in big font but actually:</p>
<ol><li>we open a websocket to localhost:3000</li>
<li>on every message coming from that websocket, we trigger a page reload</li>
</ol>
<p>Now on the Emacs side, we need to do define the function that we want to call when &#34;test.html&#34; is saved</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (defvar opened-websocket nil)

  (defun websocket-on-save ()
    (when (and opened-websocket
               (equal &#34;test.html&#34; (buffer-name (current-buffer))))
      (websocket-send-text opened-websocket &#34;refresh&#34;)))

  (add-hook &#39;after-save-hook #&#39;websocket-on-save)</code>
</pre>
<ol><li>Define a global object for our websocket and initialize it as nil</li>
<li>Define the <code>websocket-on-save</code> function which<ol><li>if our websocket is not nil</li>
<li>and we are currently editing &#34;test.html&#34;</li>
<li>we send the string &#34;refresh&#34; through our websocket</li>
</ol>
</li>
<li>Have <code>websocket-on-save</code> be called after every buffer save</li>
</ol>
<p>Now let&#39;s start the server again (if you encounter an &#34;Address already in use error&#34; you might have forgotten to stop the server in the previous example)</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (setq my-websocket-server
        (websocket-server
         3000
         :host &#39;local
         :on-open (lambda (ws) (setq opened-websocket ws))
         :on-close (lambda (_websocket) (setq opened-websocket nil))))</code>
</pre>
<ol><li>When a connection is made, we assign it to our global websocket object</li>
<li>When a connection is closed, we reset our global to nil</li>
</ol>
<p>With all that hooked up, we can make some changes to the &#34;test.html&#34; file and see them appear without refreshing!</p>
<p><img src="https://blog.abrochard.com/content/img/websocket-refreshing.gif" alt="websocket-refreshing" title="websocket-refreshing"/></p>
<p>And let&#39;s not forget to clean up by removing the hook and closing the server:</p>
<pre class="prettyprint"><code class="language-emacs-lisp">  (remove-hook &#39;after-save-hook #&#39;websocket-on-save)
  (websocket-server-close my-websocket-server)</code>
</pre>

<div class="footer">6/10/2020</div>]]></description><link>https://blog.abrochard.com/websockets.html</link><guid isPermaLink="true">https://blog.abrochard.com/websockets.html</guid></item><item><title><![CDATA[Some statistics about MELPA]]></title><description><![CDATA[<head><title>Some statistics about MELPA</title></head>
<div class="title-header"><h1>Some statistics about MELPA</h1>
<a href="/melpa-stats.html">Link</a></div>
<p>Full disclaimer first: I am not a statistician nor well versed in statistics. But I was recently very interested in knowing more about <a href="https://melpa.org/#/">MELPA</a> and how it was used. I did a bit of research, wrote a little <a href="https://github.com/abrochard/melpa-stats/blob/master/main.py">data massaging script</a>, compiled data <a href="https://github.com/abrochard/melpa-stats/blob/master/data.csv">here</a>, and went on to gather a few basic statistics about MELPA.</p>
<h2 id="header-1"><span class="section-number">1</span>First glance</h2>
<p>At the time of writing this and when the data massaging script was ran, MELPA had</p>
<ul><li>4,548 packages</li>
<li>1811 package owners</li>
<li>180,821,044 total downloads</li>
</ul>
<h2 id="header-2"><span class="section-number">2</span>Timeline</h2>
<p>The first thing I wanted to know was how many packages were added by year. MELPA started in 2012 and since then its biggest year was 2013 with 755 new packages accepted into the repo. Since then, it has been on the decline.</p>
<p><img src="https://blog.abrochard.com/content/img/packages-added-by-year.png" alt="packages-added-by-year" title="packages-added-by-year"/></p>
<h2 id="header-3"><span class="section-number">3</span>Sources</h2>
<p>No surprises here but over 95% of packages are hosted on github.com.</p>
<p><img src="https://blog.abrochard.com/content/img/Source-Distribution.png" alt="Source Distribution" title="Source Distribution"/></p>
<h2 id="header-4"><span class="section-number">4</span>Downloads</h2>
<p>The basic stats are:</p>
<ul><li>average of 39,908 downloads for a package</li>
<li>but a median of 1,831 downloads</li>
<li>with standard deviation of 148,129 downloads</li>
<li>the package with the fewest downloads was just added and sits at 7 downloads</li>
<li>the packages with the most downloads is at 2,693,349 downloads</li>
</ul>
<p>This translates into a very long tail distribution with a huge quantity of packages with &#34;few&#34; downloads and outliers with a very large number of downloads.</p>
<p><img src="https://blog.abrochard.com/content/img/Histogram-of-download-counts.png" alt="Histogram of download counts" title="Histogram of download counts"/></p>
<p>Not very useful. There are definitely fancy ways of representing long tail data but it will have to be for another time.</p>
<p>More interesting to compare is downloads to months since published.</p>
<p><img src="https://blog.abrochard.com/content/img/Months-since-added-vs-Download.png" alt="Months added vs Downloads" title="Months added vs Downloads"/></p>
<p>We can see that a lot of packages stay at a relatively low number of downloads over time meanwhile newer packages can reach a large number of downloads quickly.</p>
<p>Without thinking much, I compared the length of a package name to its download count.</p>
<p><img src="https://blog.abrochard.com/content/img/Name-length-vs-Download.png" alt="Name length vs Download" title="Name length vs Download"/></p>
<p>It seems that packages with shorter names get more downloads. My two cents theory is that they are evocative enough or a library with catchy name (ie. dash). On the other hand, packages with very long names can be extensions of extensions like (company-XXX) with more of a niche aspect to begin with.</p>
<h2 id="header-5"><span class="section-number">5</span>Owners</h2>
<p>Earlier I mentioned 1811 unique package owners. I was interested in seeing how many packages does one owner have. Obviously it averages to 2.45 packages per owner, but if I break down into buckets of 1, 2, 3, 4, and 5 and over packages I get this:</p>
<p><img src="https://blog.abrochard.com/content/img/Owners-by-Package-Count.png" alt="Owner by package count" title="Owner by package count"/></p>
<p>Which tells us that about 63% of owners published only 1 package to MELPA.</p>
<h2 id="header-6"><span class="section-number">6</span>Further steps</h2>
<p>I had quite a bit of fun looking at these numbers. I could foresee going back to the data with different questions. It would also be neat to get information about the code repositories themselves and interact with the github API to get things like total contributors per packages and number of commits.</p>
<p>And who knows, maybe an interactive page to see charts in more details.</p>

<div class="footer">4/13/2020</div>]]></description><link>https://blog.abrochard.com/melpa-stats.html</link><guid isPermaLink="true">https://blog.abrochard.com/melpa-stats.html</guid></item><item><title><![CDATA[Quick Introduction to Emacs Hyperbole]]></title><description><![CDATA[<head><title>Quick Introduction to Emacs Hyperbole</title></head>
<div class="title-header"><h1>Quick Introduction to Emacs Hyperbole</h1>
<a href="/hyperbole-intro.html">Link</a></div>
<p>I have tried to include <a href="https://www.gnu.org/software/hyperbole/">Hyperbole</a> more and more into my workflow, and to match with the upcoming release of Hyperbole 7.0.8, I wanted to share a few tricks I like.</p>
<p>This is far from covering all of Hyperbole&#39;s capabilities, but its the easiest ones to start with.</p>
<p>The number one killer feature: &#34;implicit buttons&#34;, or &#34;do what I mean here&#34;.</p>
<p>By default, put your cursor on something and hit <code>M-Return</code></p>
<h2 id="header-1"><span class="section-number">1</span>Jump to any file</h2>
The easiest to understand, just put your cursor on an absolute or relative file path, with optionally a line and column number.<p><img src="https://imgur.com/3ylbs0I.gif" alt="Hyperbole File Jump" title="Hyperbole File Jump"/></p>
<h2 id="header-2"><span class="section-number">2</span>Run a key sequence</h2>
<p>You can execute any key sequence from its text representation</p>
<p><img src="https://imgur.com/KhCc40N.gif" alt="Hyperbole Keypress" title="Hyperbole Keypress"/></p>
<h2 id="header-3"><span class="section-number">3</span>Jump to error</h2>
<p>I use that one in my daily workflow. If I get a compiler error, I can directly jump to the line causing a problem.</p>
<p><img src="https://imgur.com/Gzr0fJu.gif" alt="Hyperbole stack trace" title="Hyperbole stack trace"/></p>
<h2 id="header-4"><span class="section-number">4</span>Action buttons</h2>
<p>This is brand new, you can call any emacs lisp function or display a variable value with the <code>&#60;EXPRESSION&#62;</code> syntax.</p>
<p><img src="https://imgur.com/3bulcvG.gif" alt="Hyperbole Action Buttons" title="Hyperbole Action Buttons"/></p>
<h2 id="header-5"><span class="section-number">5</span>More cool buttons</h2>
<ul><li>External processes<pre class="prettyprint"><code class="language-text">      &#34;!/usr/local/bin/redis-cli&#34;</code>
</pre>
</li>
<li>git, github, gitlab links<pre class="prettyprint"><code class="language-text">      gh#abrochard/emacs-todoist/2a63ce7</code>
</pre>
</li>
<li>social media<pre class="prettyprint"><code class="language-text">      twitter@abrochard</code>
</pre>
</li>
</ul>
<h2 id="header-6"><span class="section-number">6</span>How to install latest</h2>
<p>I like to work off the git sources.</p>
<h3 id="header-6-1"><span class="section-number">6.1</span>Clone and make</h3>
<pre class="prettyprint"><code class="language-shell">  git clone https://git.savannah.gnu.org/git/hyperbole.git
  cd hyperbole
  make src</code>
</pre>
<h3 id="header-6-2"><span class="section-number">6.2</span>Load</h3>
<pre class="prettyprint"><code class="language-emacs-lisp">  (add-to-list &#39;load-path &#34;PATH-TO-HYPERBOLE-FOLDER&#34;)
  (load &#34;hyperbole-autoloads&#34;)
  (load &#34;hyperbole&#34;)</code>
</pre>
<h2 id="header-7"><span class="section-number">7</span>What to do next</h2>
<p>Check out the demo with <code>{C-h h d d}</code></p>

<div class="footer">1/28/2020</div>]]></description><link>https://blog.abrochard.com/hyperbole-intro.html</link><guid isPermaLink="true">https://blog.abrochard.com/hyperbole-intro.html</guid></item></channel></rss>